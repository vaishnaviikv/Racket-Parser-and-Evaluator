#lang plai-typed

; WARNING: DO NOT EDIT THIS FILE

; In this assignment, our programs can return different kinds of results.
; Value is the type assigned to the result of evaluating a program.
(define-type Value
  [numV (n : number)]
  [boolV (b : boolean)]
  [listV (vs : (listof Value))])

; AST of Expressions.
; Above each constructor we give an example of the program syntax that
; should parse to that AST node, and describe what evaluating such an
; expression should return.

(define-type Expr
  ; Every value is a valid expression. Evaluating a value should just return the value.
  [valC (v : Value)]

  ; (+ e1 e2)
  ; Evaluates e1 and e2, which can be assumed to yield numbers n1 and n2, and returns their sum.
  [plusC (e1 : Expr) (e2 : Expr)]

  ; (* e1 e2)
  ; Evaluates e1 and e2, which can be assumed to yield numbers n1 and n2, and returns their product.
  [timesC (e1 : Expr) (e2 : Expr)]

  ; (natrec e1 e2 (x y e3))
  ; Evaluates e1, which can be assumed to yield a non-negative integer n.
  ; - If n is 0, evaluates e2 and returns the result.
  ; - If n is > 0, first recursively executes (natrec (- n 1) e2 (x y e3)), to get some value v.
  ;   Then evaluates e3 with x bound to (- n 1) and y bound to v; the result of evaluating e3 is returned.
  ;
  ; E.g. evaluating (natrec 3 1 (x y (+ x y))) should return (numV 4)
  [natrecC (e1 : Expr) (e2 : Expr) (x : symbol) (y : symbol) (e3 : Expr)]

  ; (equal? e1 e2)
  ; Evaluates e1 and e2, and returns true if e1 is equal to e2, and returns false otherwise.
  [equal?C (e1 : Expr) (e2 : Expr)]

  ; (if guard e1 e2)
  ; Evaluates guard, which can be assumed to yield a boolean b.
  ; - If b is true, evaluates e1 and returns the result.
  ; - If b is false, evaluates e2 and returns the result.
  [ifC (guard : Expr) (e1 : Expr) (e2 : Expr)]

  ; (list e1 e2 ... en)
  ; Evaluates e1 through en, yielding values v1 through vn, then returns the list containing v1 through vn
  [listC (es : (listof Expr))]

  ; (cons e1 e2)
  ; Evaluates e1 and e2, yielding v1 and v2 (which can be assumed to be a list),
  ; and returns the list that adds v1 to the front of the list represented by v2.
  [consC (e1 : Expr) (e2 : Expr)]

  ; (first e)
  ; Evaluates e yielding a value v (which can be assumed to be a non-empty list),
  ; and returns the first element of v.
  [firstC (e : Expr)]

  ; (rest e)
  ; Evaluates e yielding a value v (which can be assumed to be a non-empty list),
  ; and returns the tail of v.
  [restC (e : Expr)]

  ; (listrec e1 e2 (hd rest res e3))
  ; Evaluates e1 yielding a value v, which can be assumed to be a list.
  ; - If the list v is empty, evaluates e2 and returns the result.
  ; - If v is a non-empty list of the form (v1 v2 ... vn), first recursively
  ;   evaluates (listrec (v2 ... vn) e2 (hd rest res e3)) to get some value vrec
  ;   then evaluates e3 with hd bound to v1, rest bound to (v2 ... vn), and res bound to vrec.
  ;   Returns the result of evaluating e3.
  ;
  ; E.g. evaluating (listrec (list 1 2 3) 0 (x y res (+ x res))) should return (numV 6).
  [listrecC (e1 : Expr) (e2 : Expr) (hd : symbol) (rest : symbol) (res : symbol) (e3 : Expr)]

  ; (let ([x1 e1] [x2 e2] ... [xn en]) e)
  ; would be parsed as (letC (list (pair x1 e1) (pair x2 e2) ... (pair xn en)) e)
  ; Behaves similarly to the racket "let" form: e1 through en are evaluated to get values v1 through vn,
  ; then e is evaluated with xi bound to vi respectively.
  [letC (bindings : (listof (symbol * Expr))) (e : Expr)]

  ; (let* ([x1 e1] [x2 e2] ... [xn en]) e)
  ; would be parsed as (let*C (list (pair x1 e1) (pair x2 e2) ... (pair xn en)) e)
  ; Behaves similarly to the racket "let*" form: e1 through en are evaluated to get values v1 through vn,
  ; then e is evaluated with xi bound to vi respectively.
  ; The difference between let is that in evaluating ei, the bindings for x1 through x_{i-1} are available.
  [let*C (bindings : (listof (symbol * Expr))) (e : Expr)]

  ; (unpack (x1 x2 ... xn) e1 e2)
  ; would be parsed as (unpackC (list x1 x2 ... xn) e1 e2)
  ; Evaluates e1, which can be assumed to yield a list l of the form (v1 v2 ... vn)
  ; Then returns the result of evaluating e2 with x1 bound to v1, x2 bound to v2, ..., xn bound to vn.
  ; It is assumed that the list l has the same length as the length of the 'vars' argument.
  [unpackC (vars : (listof symbol)) (e1 : Expr) (e2 : Expr)]

  ; A use of a variable x would be parsed as (idC x).
  [idC (x : symbol)]
  )
